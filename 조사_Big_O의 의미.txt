< https://velog.io/@wan088/%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-big-O-big-big- >의 내용을 수업 내용과 연관지어 정리하라

복잡도 표현
- 입력 크기에 대한 함수로 표기
- 함수는 주로 여러 개의 항을 가지는 다항식임
- 단순한 함수로 표현하기 위해 '점근적 표기(asymptotic notation)을 사용

점근적 표기 : 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법
- O(Big-Oh) 표기 : 복잡도의 점근적 상한을 나타냄
- Ω(Big-Omega) 표기 : 복잡도의 점근적 하한을 나타냄
- θ(Theta) 표기 : 복잡도의 상한과 하한이 동시에 적용됨

시간복잡도의 점근적 표기 : 입력 크기 n이 무한대로 커질 대의 복잡도를 간단히 표현하기 위해 사용하는 표기법

< 학계 이론 >

O(Big-Oh)
- f(n) = 2n^2 - 8n + 3이라면 O-표기는 O(n^2)  * 최고차항만 남김(계수 제외)
- f(n)의 단순화된 표현은 n^2이며, 임의의 상수 c를 곱한 cn^2이 n이 증가함에 따라 f(n)의 상한이 됨.(단, c>0)

[Big_O 사진]

- 이때 C>2이라면, 교차점 n=n0일 때 이후부터는 f(n)은 cn^2보다 절대 커질 수 없음(기울기)
- 이와 같이 교차점 이후 상한 관계를 만족하는 C가 존재한다면 f(n) = O(n^2)으로 표기 가능
- f(n) != O(nlogn), O(logn), O(n)
- f(n) = O(2^n), O(n^3)

Ω(Big-Omega)
- f(n) = 2n^2 - 8n + 3이라면 Ω-표기는 Ω(n^2)  * 최고차항만 남김(계수 제외)
- n이 증가함에 따라 f(n)이 cn^2보다 작을 수 없다 -> 점근적 하한

[Big_Omega 사진]

- f(n) = Ω(nlogn), Ω(logn), Ω(n) : 어떤 상수 c를 선택하느냐에 따라 f(n)보다 작게 만들 수 있음
- f(n) != O(2^n), O(n^3) : 어떤 상수 c를 선택해도 f(n)보다 작게 만들 수 없음

θ(Theta)
- O 표기와 Ω 표기가 같은 경우에 사용
- f(n) = 2n^2 - 8n + 3일 때 O(n^2), Ω(n^2)이므로 θ(n^2)로 나타낼 수 있음
- f(n)은 n이 증가함에 따라 n^2와 동일한 증가율을 가진다

[Theta 사진]

- g(n) n0보다 큰 모든 n에 대해서 c=c1일 때는 f(n)보다 작지만, c=c2일 때는 f(n)보다 크다
- O 표기와 Ω 표기가 다른 n, nlogn, n^3, 2^n은 θ 표기로 나타낼 수 없음

< 실제 사용 >

O (Big-Oh)
- 학계에서는 '시간의 상한'을 나타내지만, 현업에서의 사용은 'θ 표기'에 더 근사하다
- 배열의 모든 값을 출력하는 알고리즘의 시간복잡도를 O(N)으로 표현 가능, 또는 O(N^2), O(N!)으로 표현해도 문제되지 않는다.(해당 알고리즘이 Big-O로 표현된 시간보다 빠르기만 하면 됨. - 그래프 참고)

Ω (Big-Omega)
- 잘 사용되지 않는다.

θ (Big-Theta)
- 실질적으로 가장 중요한 개념 (왜? Big-O는 뭐든 그냥 O(N!)하면 되고, Big-Omega는 반대로 Ω(1)해버려도 문제가 되지 않음.

퀵 정렬과 복잡도

- 최선의 경우 (모든 원소가 동일할 경우) : 퀵 정렬은 평균적으로 한 차례 배열을 순회하고 종료 = O(1)
- 최악의 경우 (Pivot을 최소값 또는 최대값으로 값게된 경우) : 퀵 정렬의 부분 정렬에 대한 이점이 사라짐 = O(N^2)

*알고리즘의 수행시간을 따질 땐, 경우에 따라 다른 시간복잡도가 나올 수 있으며, 최선의 경우보다 평균 또는 최악의 경우를 주로 고려한다.

시간복잡도 *표정리

[Big-O 사진]

▢ O(1) - 상수 시간
▢ O(logn) - 로그(대수) 시간
▢ O(n) - 선형 시간
▢ O(nlogn) - 로그 선형 시간
▢ O(n^2) - 이차 시간
▢ O(n^3) - 3차 시간
▢ O(2^n) - 지수 시간
