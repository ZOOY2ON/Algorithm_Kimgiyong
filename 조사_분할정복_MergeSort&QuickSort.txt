https://www.youtube.com/watch?v=QAyl79dCO_k
(참고) https://www.youtube.com/watch?v=FCAtxryNgq4

Merge Sort(병합 정렬)
- 정렬되어 있는 두 배열을 하나로 합치면서 배열하는 정렬 방법
- 두 배열에서 작은 값을 선택하여 하나의 배열에 추가하고, 이 작업을 반복하여 두 배열을 병합
- 배열을 반으로 나누고, 각각을 병합하여 정렬된 배열을 생성

시간 복잡도 : O(n log n)
- 파티션을 나눌 때 데이터 양이 절반씩 줄어들어 로그(n)가 되기 때문

*분할 정복 알고리즘
- 복잡한 문제를 작은 문제로 분할, 각 부분 문제를 해결한 뒤 이를 합쳐 복잡한 문제를 해결하는 알고리즘

알고리즘 동작 방식
- 주어진 배열을 두 개의 작은 배열로 분할
- 작은 배열을 정렬하고 병합
- 정렬된 작은 배열들을 계속 병합하여 큰 배열 생성

https://www.youtube.com/watch?v=7BDzle2n47c&t=517s
(참고) https://www.youtube.com/watch?v=cWH49IKDIiI

Quick Sort(퀵 정렬)
- 정렬되지 않은 배열을 정렬하기 위한 알고리즘으로 분할 정복 방식을 사용한다.
- 배열에서 임의의 값을 선택, 그 값을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 이동시켜 두개의 파티션으로 나눔
- 이후 각 파티션에 대해 재귀적으로 동일한 작업 수행, 최종적으로 모든 파티션이 정렬됨
- Pivot이라는 요소를 선택하여 배열을 두 그룹으로 분할 함(Pivot을 선택하는 방법에 따라 알고리즘의 성능이 달라짐)

알고리즘 동작
- 배열에서 pivot을 선택, pivot의 선택 방법에 따라 정렬 속도가 달라짐
- pivot을 기준으로 배열을 분할, 작은 요소는 pivot의 왼쪽, 큰 요소는 pivot의 오른쪽으로 이동
- 분할 된 하위 배열에 대해 재귀적으로 퀵 소트를 적용

시간 복잡도 : O(n log n)
- 단, 최악의 경우에는 O(n^2)

피벗 값 선택
- 배열이 정렬되어 있지 않기 때문에 피벗 값으로 중간 값을 선택 할 수 없음 물리적으로 중간에 있는 값을 선택함
- 중간에 있는 값이 배열에서 최소 또는 최대값인 경우 비대칭한 파티션을 생성할 수 있음

파티션 함수
- 피벗 값을 기준으로 배열을 두 파티션으로 나누는 함수를 구현
- 배열의 양 끝에서 시작하는 두 포인터를 사용하여 작은 값과 큰 값의 위치를 바꾸며 파티션을 나눔

Quick Sort 함수
- 배열과 시작 및 끝 지점의 인덱스를 인자로 받아 퀵 정렬을 수행
- 두 개 이상의 값이 있는 경우에만 해당 파티션에 대해 재귀적으로 호출하여 정렬을 진행함