##1. Knight's Tour (knight's move) 가 무엇인지 조사하라. 최대한 많은 정보를 조사하기로 한다.

*나이트(Knight)는 '수직 운동 두칸 -> 수평 운동 한칸'으로 움직인다.

Knight's Tour
 : N x N 체스 보드가 주어졌을 때, 체스판 위에서 나이트가 모든 칸을 한 번씩 방문하는 문제로 이 문제의 목표는 나이트가 체스판 위의 모든 칸을 한 번 씩 방문하면서 움직일 수 있는 경로를 찾는 것이다.

---- Knight's tour의 해결 방안 : Backtracking 알고리즘 ----

1. 체스판을 초기화 한다 : 먼저 체스판을 생성하고 모든 칸을 -1로 초기화 한다. 이때 -1은 해당 칸이 아직 방문되지 않음을 나타낸다.
2. 시작 위치를 설정한다 : 나이트의 시작 위치를 정하고 해당 위치를 체스판에 방문했다고 표시한다.
3. 재귀적으로 해를 찾아본다 : 
- 현재 위치에서 나이트의 다음 움직일 수 있는 위치를 검사한다.
- 가능한 움직임 중에서 아직 방문하지 않은 칸을 선택하고, 해당 칸으로 이동한다.
- 위의 과정을 재귀적으로 반복한다.(이때 만약 모든 칸을 방문했다면 문제를 해결한 것이므로 알고리즘을 종료한다.)
4. 백트래킹 : 
- 만약 현재 위치에서 더 이상 움직일 수 있는 위치가 없다면, 이전 위치로 돌아가기 위해 백트래킹을 수행한다.(이전 위치로 돌아가고 해당 위치에서 다른 가능한 움직임 시도)
- 단, 이전 위치로 돌아갈 때 이전 위치의 상태를 원래대로 복원해야함
5. 해결 여부 확인 : 모든 칸을 방문한 경우(=모든 움직임을 수행한 경우) 나이트 투어 문제를 해결한 것으로 간주함.

백트래킹 알고리즘 사용의 장점
1. 정확성 : 백트래킹 알고리즘을 사용하면 가능한 모든 경우를 검사하므로 정확한 해를 찾을 수 있다.( = 올바른 결과를 보장한다.)
2. 모든 해 찾기 : 백트래킹은 모든 가능한 해를 찾을 수 있는 방법이다. ( = 모든 해를 필요로 하는 경우에 유용하다.)
3. 일반성 : 나이트 투어 문제 뿐만 아니라 다양한 다른 문제에도 적용 가능한 범용적인 알고리즘 패턴이다.

백트래킹 알고리즘 사용의 단점
1. 지수 시간 복잡도 : 큰 입력에 대해서는 백트래킹 알고리즘이 실행 시간이 급격하게 증가하므로 계산 비용이 매우 높다. ( = 나이트 투어 문제의 경우 큰 체스판에서는 실용적으로 해결하기 어려울 수 있다.)
2. 효율성 문제 : 백트래킹 알고리즘은 모든 가능한 경로를 탐색하기 때문에 중복 계산이 발생할 수 있다. ( = 효율성이 떨어질 수 있다.)
3. 메모리 사용 : 큰 체스판의 경우 메모리 사용량도 증가할 수 있으며, 이는 문제를 해결하기 위해 필요한 메모리를 늘릴 수 있다.
4. 최적화의 어려움 : 나이트 투어 문제의 경우 최적화를 위한 휴리스틱이나 고급 기술을 적용하기 어려울 수 있으며, 실행 시간을 단축시키는 것이 어려울 수 있다.

결론
백트래킹 알고리즘은 정확하고 모든 가능한 해를 찾을 수 있는 장점이 있지만, 큰 입력에 대해서는 실행 시간가ㅘ 메모리 사용량이 급증하고 효율성 문제가 발생할 수 있다. 따라서 문제에 따라 다른 알고리즘과 함께 사용하거나 최적화 기법을 적용하는 것이 필요할 수 있다.

백트래킹 알고리즘을 사용한 Python 코드

def is_valid_move(board, n, x, y, move):
    # 이동 가능한 범위 확인
    if x >= 0 and y >= 0 and x < n and y < n:
        # 방문하지 않은 칸인지 확인
        if board[x][y] == -1:
            return True
    return False

def knight_tour(n):
    # 체스판 초기화
    board = [[-1 for _ in range(n)] for _ in range(n)]
    
    # 나이트의 이동 방향 정의 (상대 좌표)
    move_x = [2, 1, -1, -2, -2, -1, 1, 2]
    move_y = [1, 2, 2, 1, -1, -2, -2, -1]
    
    # 시작 위치 설정 (0, 0)
    board[0][0] = 0
    
    # 백트래킹을 사용한 해 찾기
    if solve_knight_tour(board, n, 0, 0, 1, move_x, move_y):
        print("나이트 투어 경로:")
        for row in board:
            print(row)
    else:
        print("나이트 투어 경로가 없습니다.")

def solve_knight_tour(board, n, x, y, move_num, move_x, move_y):
    if move_num == n**2:
        return True
    
    for i in range(8):
        next_x = x + move_x[i]
        next_y = y + move_y[i]
        if is_valid_move(board, n, next_x, next_y, move_num):
            board[next_x][next_y] = move_num
            if solve_knight_tour(board, n, next_x, next_y, move_num + 1, move_x, move_y):
                return True
            board[next_x][next_y] = -1  # 백트래킹
    return False

# 예시: 5x5 체스판에서 나이트 투어 경로 찾기
knight_tour(5)

---- Knight's tour의 최적화 및 휴리스틱 기법의 사용 ----

* 휴리스틱 : 불충분한 시간이나 정보로 인하여 합리적인 판단을 할 수 없거나, 체계적이면서 합리적인 판단이 굳이 필요하지 않은 상황에서 사람들이 빠르게 사용할 수 있게 보다 용이하게 구성된 간편 추론의 방법으로 기본적으로 모두 최적해가 될 가능성이 없는 답들을 탐색하는 것을 방지하여, 만들어 봐야 할 답의 수를 줄이는 것을 목표로 한다.

1. Warnsdorff's Rule(워스도프 규칙)
 : 각 단계에서 현재 위치에서 이동할 수 있는 위치 중에서 가장 이웃이 적은 위치로 이동하는 것을 권장(가능한 이동 경로를 줄여서 더 빠르게 해를 찾을 수 있음)
2. 빠른 엑세스 휴리스틱(Fast Access Heuristic)
 : 체스판을 미리 나누어 여러 영역으로 나눈 다음, 나이트가 특정 영역으로 들어갔을 때 해당 영역 내에서만 이동하도록 하는 방법이다. (나이트가 전체 체스판을 이동하는 것보다 훨씬 효율적으로 움직일 수 있습니다.)
3. 먼저 방문 휴리스틱(First Visit Heuristic)
 : 방문하지 않은 칸 중에서 가장 적게 방문한 칸으로 이동하는 방법(가능한 경로를 더 효율적으로 찾을 수 있음)
4. 동적 프로그래밍(Dynamic Programming)
 : 큰 체스판의 경우 동적 프로그래밍을 사용하여 부분 문제의 해를 저장하고 재사용함으로써 계산 속도를 높일 수 있음
5. 카이사 주기성(Kaisa Periodicity)
 : 특정 크기의 체스판에 대해 카이사 주기성을 이용하여 해를 찾는 방법으로 카이사 주기성은 일정한 주기로 반복되는 패턴을 나타내며, 이를 활용하여 특정 크기의 체스판에 대한 해를 찾을 수 있음

##2. Knight's Tour 의 해를 찾기 위한 프로그램을 개발하기로 했는데, Back-Tracking 기법을 사용하기로 했다.

2-1. 이 기법을 사용하여 해를 구하는 것을 pseudo code 를 사용하여 기술해 보라

Procedure KnightTour(n):
    Initialize an n x n chessboard with all cells marked as unvisited
    
    // Define the relative moves of the knight
    move_x = [2, 1, -1, -2, -2, -1, 1, 2]
    move_y = [1, 2, 2, 1, -1, -2, -2, -1]
    
    // Start the tour from the first cell (0, 0)
    Set the starting cell (0, 0) as visited and mark it as move 1
    
    If SolveKnightTour(board, n, 0, 0, 2, move_x, move_y) returns true:
        Print "Knight's Tour path found:"
        Print the board with visited cells
    Else:
        Print "No Knight's Tour path found."

Function SolveKnightTour(board, n, x, y, move_num, move_x, move_y):
    If move_num equals n^2:
        Return true // All cells have been visited
    
    For each valid move (dx, dy) among the knight's possible moves:
        next_x = x + dx
        next_y = y + dy
        If (next_x, next_y) is a valid unvisited cell on the board:
            Mark (next_x, next_y) as visited with move_num
            If SolveKnightTour(board, n, next_x, next_y, move_num + 1, move_x, move_y) returns true:
                Return true // Knight's Tour path found
            Mark (next_x, next_y) as unvisited (backtrack)
    
    Return false // No valid path found from this cell

// Example usage:
KnightTour(5) // Find a Knight's Tour path on a 5x5 chessboard

2-2. 이때 예상되는 실행 시간은 얼마인가? 하나의 길을 가 보는 것을 1 단위시간이라고 했을 때 모든 해를 구하려고 한다면 대략적으로 얼마에 가까운 단위시간이 필요한가?

*단위 시간 : 알고리즘 분석에서 사용되는 상대적인 개념으로, 알고리즘의 실행 시간과 작업량을 비교하고 분석하는데 도움을 주며, 실제로 1 단위 시간이 어느 정확한 시간 단위에 상응하는지 중요하지 않음. 알고리즘 간의 상대적인 성능을 이해하는 데 사용됨.

Knight's tour 문제를 해결하는 코드으 실행 시간은 Back-Tracking 알고리즘의 특성에 따라 체스판의 크기인(n)에 따라 크게 달라지게 되는데, 체스판의 크기가 커질수록 실행 시간이 급격하게 증가하게 됨.(일반적으로 지수 시간 복잡도를 가짐 )
*n=1 : 실행 시간은 상수 시간
*n=2 : 실행 시간은 상수 시간
*n=3 : 실행 시간은 몇 초 내에 완료될 수 있음
*n=4 : 실행 시간은 상당한 시간이 거릴 수 있음
*n=5 이상 : 실행 시간은 지수적으로 증가(매우 오랜 시간이 걸릴 수 있음)

2-3. 수퍼컴퓨터가 1초에 1억 단위시간을 처리할 수 있다고 가정하면 (그런 컴퓨터는 현재 기술상 없지만) 이 컴퓨터로 이 문제를 해결하는 데 얼마의 시간이 걸리는가?

나이트 투어 문제의 시간 복잡도가 지수 시간 복잡도인 경우, 문제의 크기에 따라 슈퍼 컴퓨터가 처리하는데 걸리는 시간이 기하급수적으로 늘어나게 됨.

1억 단위시간을 처리할 수 있더라도 나이트 투어 문제를 큰 체스판에서 모든 가능한 해를 찾는 다고 한다면 여전히 매우 오랜 시간이 걸릴 것임.
큰 체스판의 경우에 시간이 급격하게 증가하므로 1억 단위시간 단위로 측정할 때 몇 시간 ~ 몇 년까지 계산을 수행해야 할 가능성이 있음.

3. 정렬 방법에는 다양한 알고리즘이 있다.

3-1. 최대한 많은 알고리즘에 대해 조사하고 각 알고리즘의 시간 성능을 Big-O notation 을 이용하여 표시하라.

삽입정렬
 : 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교 하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘
매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다.
선택정렬
 : 선택 정렬은 첫 번째 자료를 두 번째 자료부터 마지막 자료까지 차례대로 비교하여 가장 작은 값을 찾아 첫 번째에 놓고, 두 번째 자료를 세 번째 자료부터 마지막 자료까지와 차례대로 비교하여 그 중 가장 작은 값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬을 수행한다.
1회전을 수행하고 나면 가장 작은 값의 자료가 맨 앞에 오게 되므로 그 다음 회전에서는 두 번째 자료를 가지고 비교한다. 마찬가지로 3회전에서는 세 번째 자료를 정렬한다.
버킷정렬
 : 버킷 정렬은 계수 정렬을 일반화 한 것으로 간주할 수 있다.
계수 정렬은 키 값이 작은 범위 안에 들어올 때 적용할 수 있는 방법이지만 버킷 정렬은 키 값의 범위뿐만이 아니라 그 범위 내에서 키값이 확률적으로 균등하게 분포된다고 가정할 수 있을 때 적용할 수 있는 방법이다.
버블정렬
 : 버블 정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, … 이런 식으로 (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.
1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 자료까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.
셸정렬
 : 정렬해야 할 리스트의 각 k번째 요소를 추출해서 부분 리스트를 만든다. 이때, k를 ‘간격(gap)’ 이라고 한다.
간격의 초깃값: (정렬할 값의 수)/2
생성된 부분 리스트의 개수는 gap과 같다.
각 회전마다 간격 k를 절반으로 줄인다. 즉, 각 회전이 반복될 때마다 하나의 부분 리스트에 속한 값들의 개수는 증가한다.
간격은 홀수로 하는 것이 좋다.
간격을 절반으로 줄일 때 짝수가 나오면 +1을 해서 홀수로 만든다.
간격 k가 1이 될 때까지 반복한다.
퀵정렬
 : 하나의 리스트를 피벗(pivot)을 기준으로 두 개의 비균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.
퀵 정렬은 다음의 단계들로 이루어진다.
분할(Divide): 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할한다.
정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.
결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.
순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.
병합정렬
 : 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.
합병 정렬은 다음의 단계들로 이루어진다.
분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.
정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.
결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.
합병 정렬의 과정
추가적인 리스트가 필요하다.
각 부분 배열을 정렬할 때도 합병 정렬을 순환적으로 호출하여 적용한다.
합병 정렬에서 실제로 정렬이 이루어지는 시점은 2개의 리스트를 합병(merge)하는 단계 이다.
트리정렬
힙정렬
 : 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법
내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다.
과정 설명
정렬해야 할 n개의 요소들로 최대 힙(완전 이진 트리 형태)을 만든다.
내림차순을 기준으로 정렬
그 다음으로 한 번에 하나씩 요소를 힙에서 꺼내서 배열의 뒤부터 저장하면 된다.
삭제되는 요소들(최댓값부터 삭제)은 값이 감소되는 순서로 정렬되게 된다.
기수정렬
 : 기수정렬은 낮은 자리수부터 비교하여 정렬해 간다는 것을 기본 개념으로 하는 정렬 알고리즘. 기수정렬은 비교 연산을 하지 않으며 정렬 속도가 빠르지만, 데이터 전체 크기에 기수 테이블의 크기만한 메모리가 더 필요하다.
timsort
 : Insertion sort(삽입정렬)와 Merge sort(합병정렬)를 결합하여 만든 정렬 알고리즘입니다. Tim Sort 알고리즘의 최선 시간 복잡도는 O(n), 평균은 O(nlogn), 최악의 경우는 O(nlogn)입니다. Tim sort는 안정적인 두 정렬 방법을 결합했기에 안정적이며, 추가 메모리는 사용하지만 기존의 Merge sort에 비해 적은 추가 메모리를 사용하여 다른 정렬 알고리즘의 단점을 취대한 극복한 알고리즘입니다.
introsort
 : 하이브리드 정렬의 종류, 선택적 정렬의 종류, 개선된 퀵정렬
퀵소트은 피벗을 하여 선택된 것을 분할(파티션) 하여 재귀 호출(분할정복방식)로 정렬하는 방식인데, 분할 되는 횟수(파티션 횟수)가 많을 수록(bad partition) 오버헤드로 인한 성능저하가 발생한다.
그렇기 때문에, 분할 되는 횟수를 스스로 모니터링(자기성찰? 내성적? introspective) 하다가 정의한 임계값에 도달 했을 경우, 힙정렬로 스위칭 하는 방식으로 개선 한 것이 바로 인트로스펙티브 정렬이라 할 수 있겠다.
평균 시간복잡도는 퀵소트와 같고 최악의 시간복잡도는 힙정렬의 알고리즘을 따른다.

3-2. https://www.youtube.com/watch?v=kPRA0W1kECg 를 보고 영상의 각 부분이 의미하는 바를 정리하라.
화면상에 나타나는 숫자나 막대의 두께(갯수) 등을 언급하라.

-선택 정렬-
1. 초반 0:02 까지는 위아래로 전체모습이 지그재그 형태인 막대들이 나열 되어 있다.
2. 0:08 까지 막대모양이 대각선 (거의 일직선)의 형태를 띄고 있다. / 막대의 두께는 이전과 동일한 것으로 보인다.
-삽입 정렬-
3. 0:12에 등장한 전체 모습이 지그재그 형태인 막대들은 이전의 1번 보다 두께가 얇아졌다. / 최저 길이도 더 짧아졌다.
4. 0:38까지 막대모양이 대각선 (거의 일직선)의 형태가 띄게 되는데, 그 과정에서 이전보다 굴곡이 많이 보이다가 일직선으로 정리된다. 또한 시간도 많이 걸리는 모습을 보여준다.
-빠른 정렬-
5. 0:40에 등장한 전체 모습이 지그재그 형태인 막대들은 이전의 3번 보다 두께가 얇아졌다.
6. 이번에는 양쪽에서 변화가 시작된다. ( 먼저 진행된 방향으로는 다른 방향의 것은 진행되지 않는 것으로 보임 )
7. 우측은 길이가 긴 막대가 많은 것으로 보이고 ( 오른쪽에서 시작된 부분 ), 좌측으로 갈수록 길이가 반씩 줄어드는 것으로 보인다.
8. 그러다가 1:03 까지 막대모양이 대각선 (거의 일직선)의 형태가 띄게 되는데, 4번의 과정보다 빠르게 바뀌었다.
-병합 정렬-
9. 1:08초에 등장한 전체 모습이 지그재그 형태인 막대들은 이전 3번과 비슷한 두께
10. 1:26 까지 막대모양이 대각선 (거의 일직선)의 형태가 띄게 되는데, 그 과정에서 막대가 '합쳐지는'듯 작은 대각선들이 만들어졌다가 합쳐지면서 커지는 모습을 볼 수 있다.
-힙 정렬-
11. 1: 29에 등장한 전체 모습이 지그재그 형태인 막대들은 이전 5번과 비슷한 두께
12. 진행되면서  막대의 길이가 점차 짧아지는 모습을 볼 수 있다.
14. 1:54 까지 막대모양이 대각선 (거의 일직선)의 형태가 띄게 되는데, 대각선이 우측(상단)에서 부터 만들어지는 것이 이전의 알고리즘들과 차이가 있다.
 -기수 정렬(LSD)-
15. 1:57에 등장한 전체 모습이 지그재그 형태인 막대들은 이전 3번과 비슷한 두께
16. 진행되면서 막대의 길이가 점차 얇아지는 모습을 볼 수 있다. (얇고+빽빽)
17. 점차 막대의 길이가 대각선으로 맞춰지다가(한 개가 아닌 여러개의 대각선/가장긴,중간,가장짧은)
18. 세 부분에서 시작되어 2:09 까지 막대모양이 대각선 (거의 일직선)의 형태가 띄게 된다.
-기수 정렬(MSD)-
19. 2:11에 등장한 전체 모습이 지그재그 형태인 막대들은 이전 3번과 비슷한 두께
20. 진행되면서 세부분으로 나뉘어지게 되는 모습을 보여준다.
21. 가장 우측은 길이가 짧아졌고, 중간은 길이가 중간정도로 맞춰졌고, 가장 좌측은 길이가 길어지고 빽빽해졌다.
22. 2:30 까지 각 부분이 점차 대각선으로 맞춰지다 이윽고, 세부분이 이어져서 한 개의 큰 대각선(거의 일직선)의 형태가 띄게 된다.
-std:::sort(intro sort)-
23. 2:33에 등장한 전체 모습이 지그재그 형태인 막대들은 이전 5번보다 막대의 두께가 얇아졌다.
24. 진행되면서 5부분으로 나뉘어 막대의 길이가 조절되고, 계단의 형태를 띈다.
25. 3:03 까지 우측부터 대각선으로 맞춰진다 / 이전보다 시간이 조금더 걸린것으로 보인다.
-std::stable_sort(적응적 병합 정렬)-
26. 3:07에 등장한 전체 모습이 지그재그 형태인 막대들은 이전 23번과 비슷한 두께
27. 진행되면서 짧은 길이의 막대들이 조금씩 길어지는 것으로 보인다.
28. 3:35 까지 막대모양이 대각선 (거의 일직선)의 형태가 띄게 되는데, 그 과정에서 막대가 '합쳐지는'듯 작은 대각선들이 만들어졌다가 합쳐지면서 커지는 모습을 볼 수 있다. / 시간이 조금 걸리는 것으로 보임
-셸 정렬-
29. 3:37에 등장한 전체 모습이 지그재그 형태인 막대들은 이전 23번과 비슷한 두께
30. 진행되면서 막대의 길이가 점차적으로 짧아지면서 대각선의 형태를 띄어간다.
31. 3: 58 까지 막대모양이 대각선 (거의 일직선)의 형태가 띄게 된다.
-버블 정렬-
32. 4:00에 등장한 전체 모습이 지그재그 형태인 막대들은 이전 1번과 비슷한 두께
33. 진행되면서 막대들이 점점 우측으로 밀려나는데 그러면서 전체적으로 막대의 크기가 작아진다.
34. 4:16 까지 막대모양이 대각선 (거의 일직선)의 형태가 띄게 된다.
-칵테일 셰이커 정렬-
35. 4:18에 등장한 전체 모습이 지그재그 형태인 막대들은 이전 1번보다 막대의 두께가 얇아졌다.
36. 진행되면서 막대들이 점점 중앙으로 압축되어지는데, 그러면서 전체적으로 막대의 크기가 줄어든다.
37. 4:30 까지 막대모양이 대각선 (거의 일직선)의 형태가 띄게 된다.
-gnome sort-
38. 4:33에 등장한 전체 모습이 지그재그 형태인 막대들은 이전 35번과 비슷한 두께
39. 4:51 까지 막대모양이 대각선 (거의 일직선)의 형태가 띄게 되는데, 시간이 조금 걸리는 것으로 보인다.
-bitonic sort-

4. 한붓그리기가 가능한 경우와 불가능한 경우는 무엇을 보고 말할 수 있는가?

홀수 점의 개수가 0이거나, 2인 경우에만 가능하며, 홀수점이 그보다 많으면 한 번에 떼지 않고 그리기가 불가능하다.
