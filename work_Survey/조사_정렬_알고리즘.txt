1. 다음 영상을 시청하고 내용을 간략히 정리하라. 

# Bubble/Selection/Insertion Sort : https://www.youtube.com/watch?v=Bor_CRWEIXo
Big-O : 알고리즘의 퍼포먼스를 이해하기 쉽고 효율적으로 작성하는 방법

Sorting : 무언가 정리하는 것 (ex. A~Z 기준으로 정렬, 큰 수 ~ 작은 수 정렬)

이진 탐색과 같은 빠른 알고리즘을 사용하기 위해서는 '정렬'이 사전에 되어있어야 함.

(1) Bubble Sort : 버블정렬
- 자주 사용되지 않음
- 이해하기 쉬움
- 배열의 2개를 선택 오른쪽과 왼쪽 값을 비교, 큰 값을 오른쪽으로 이동 (반복)
- 시간 복잡도 : O(n^2)
*배열의 N-1의 아이템과 비교 ... 를 반복 (최악의 경우, 모든 배열을 교환해야 함)

(2) Selection Sort : 선택정렬
- 배열 중 가장 값이 작은 배열의 위치를 변수에 저장
- 저장 된 위치에 있는 가장 작은 수를 인덱스 0번으로 옮김
- 인덱스 1~n번까지 중 가장 작은 배열의 위치를 변수에 저장 ... (반복)
- 시간 복잡도 : O(n^2)
*배열의 N-1의 아이템과 비교 ... 를 반복 (최악의 경우 모든 배열을 교환할 일이 없음 : 최소 값을 찾아서 고정하기 때문)

(3) Insertion Sort : 삽입정렬
- 인덱스 1번을 기준으로 왼쪽(인덱스 0번) 값과 비교 ... 인덱스 N번을 기준으로 인덱스 N-1번의 값과 비교(반복)
- 시간 복잡도 : O(n^2)

# Bubble Sort : https://www.youtube.com/watch?v=YbsQiiubO74
버블 정렬 : 배열을 처음부터 끝까지 반복하여 인접한 두 항목을 비교하고 필요한 경우에 위치를 바꾸어 정렬하는 방법

알고리즘의 동작 방식
- 배열의 앞에서부터 순차적으로 작은 값을 앞으로 이동시킨다
- 위의 내용을 반복하며 정렬을 수행한다.

=== Java code ===


*정렬 함수는 배열을 받아서 정렬되지 않은 부분의 마지막 인덱스와 배열 주소를 인자로 받아서 작동


# Selection Sort : https://www.youtube.com/watch?v=uCUu3fF5Dws
선택 정렬 : 배열을 순회하면서 가장 작은 값을 찾아 앞으로 이동시키는 방법

알고리즘의 동작 방식
- 배열을 처음부터 끝까지 검색하면서 가장 작은 값을 찾는다
- 찾은 값을 변수에 저장한다.
- 저장한 값을 배열의 앞으로 이동시킨다.

=== Java code ===


*정렬 함수는 배열을 받아서 정렬되지 않은 부분의 시작 인덱스와 배열 주소를 인자로 받아 작동

선택 정렬 알고리즘의 시간 복잡도
- 배열의 크기가 n일 때 O(n^2)의 시간이 소요된다

# Shell Sort : https://www.youtube.com/watch?v=nyTxe-sR0rw
셀 정렬 : 다른 정렬 알고리즘과 달리 이름이 알고리즘 형태와 무관하게 정해졌음(개발자의 이름을 따서 명명되어짐)

- 삽입 정렬의 단점을 보완하기 위해 개발된 알고리즘
* 삽입 정렬은 배열의 인접한 요소를 비교하는 반면 셸 정렬은 간격을 두고 비교함, 섞여 있는 경우에도 빠르게 정렬 가능
- 셸 정렬은 간격(Gap)을 사용하여 배열을 여러 부분으로 나누고, 각 부분에 대해 삽입 정렬을 수행할 수 있음
- 간격(Gap)은 초기에는 배열 크기의 절반으로 설정, 이후에는 절반을 계속해서 나눠가며 줄여나감
* 홀수 간격을 사용하면 더 효율적으로 동작할 수 있음
- 셸 정렬은 삽입 정렬과 함께 사용하는 삽입 정렬 로직을 포함하며, 간격을 조절해가면서 정렬을 완료함.

셸 정렬 알고리즘의 시간 복잡도
- 셸 정렬은 평균적으로 좋은 성능을 보이는 편
- 시간 복잡도가 간격(Gap)의 선택에 따라 달라짐
- 일반적으로 O(n log^2 n)에서 O(n^2)범위 내

=== C code ===



# Heap 관련
>Tree 기본 (특히: Complete Binary Tree) : https://www.youtube.com/watch?v=LnxEBW29DOw
트리 : 
- 부모-자식 관계를 가지는 데이터 구조, 계층적으고 그룹화된 구조를 가짐.
- 트리의 노드는 하나 이상의 자식 노드를 가질 수 있으며, 노드의 차일드 수에 따라 다양한 종류의 트리가 있음

- 트리의 종류에는 다양하나 특성과 조건이 적용되기 때문에 각각 트리 유형은 다른 용도와 성능, 특성을 가짐
* 어떤 종류의 트리를 선택할 지는 데이터 구조의 요구 사항과 목적에 따라 결정되어야 함.

(1) 이진 트리 (Binary Tree):

- 노드가 최대 두 개의 자식 노드를 가지는 트리
- 왼쪽 자식 노드는 현재 노드보다 작아야 하고, 오른쪽 자식 노드는 현재 노드보다 커야 함
- 이진 검색 트리(Binary Search Tree, BST)는 이진 트리의 한 종류로, 정렬된 데이터 관리에 사용됨

(2) 완전 이진 트리 (Complete Binary Tree):

- 모든 노드의 레벨이 같고, 마지막 레벨을 제외한 모든 서브 트리가 왼쪽부터 차례대로 채워진 트리
- 완전 이진 트리는 트리의 레벨이나 높이가 일정하게 유지되는 것이 특징

(3) 포화 이진 트리 (Full Binary Tree):

- 모든 노드가 0개 또는 2개의 자식 노드를 가지는 트리
- 레벨별로 노드가 꽉 채워져 있어 피라미드 형태를 가지는 경우가 많음

(4) 퍼펙트 바이너리 트리 (Perfect Binary Tree):

- 모든 노드가 2개의 자식 노드를 가지며, 모든 레벨이 꽉 채워진 트리
- 레벨의 개수를 n이라고 할 때, 총 노드의 개수는 2^n - 1

>Binary Heap : https://www.youtube.com/watch?v=jfwjyJvbbBI
힙 : 최대값 또는 최소값을 효율적으로 찾아내기 위한 자료 구조
* 완전 이진 트리 형태를 기반으로 함

- 힙은 우선순위 큐와 같은 응용 분야에서 자주 사용
- 데이터의 우선 순위에 따라 처리 할 때 효과적으로 활용 됨

(1) 최소 힙 (Min Heap):
최소값을 항상 루트 노드에 위치시키는 힙입니다. 즉, 모든 노드는 자식 노드보다 작은 값을 가집니다.

(2) 최대 힙 (Max Heap):
최대값을 항상 루트 노드에 위치시키는 힙입니다. 즉, 모든 노드는 자식 노드보다 큰 값을 가집니다.

노드 삽입
- 완전 이진 트리의 맨 끝에 새로운 노드 추가
- 트리를 밸런스가 유지되도록 상위 노드와 비교, 위치 조정
* 최소 힘의 경우 부모 노드부다 작은 값을 가지도록, 최대 힙의 경우 부모 노드보다 큰 값을 가지도록함

최소/최대 값 추출
- 최소 힙의 경우, 가장 작은 값을 루트에서 추출, 최대 힙의 경우 가장 큰 값을 추출
- 추출한 루트를 비어 있는 자리에 채움, 정렬이 안 된 상태이므로 자식 노드와 비교하면서 위치를 조정
- 위의 과정을 반복하며 최소 힙/최대 힙의 성질을 유지

힙 알고리즘의 시간 복잡도
- 일반적으로 O(lon n)

>Heap Sort (특히: Complete Binary Tree 를 배열로 표현하는 법) : https://www.youtube.com/watch?v=iyl9bfp_8ag

Heap Sort (힙 정렬)
- 정렬 알고리즘 중 하나로, 특히 힙(Heap) 자료 구조를 활용하여 정렬하는 방법
- 힙은 최대 힙(Max Heap) 또는 최소 힙(Min Heap)으로 구성된 완전 이진 트리
- Complete Binary Tree(완전 이진 트리)는 데이터가 왼쪽부터 차례대로 채워지는 이진 트리 구조

Complete Binary Tree (완전 이진 트리)
- 이진 트리(Binary Tree)에서 각 노드가 최대 두 개의 자식 노드를 가지며, 왼쪽 자식부터 차례대로 채워지는 구조
- Complete Binary Tree는 중간에 비어 있는 공간이 없이 데이터가 왼쪽부터 차례대로 채워진 형태를 의미
- Complete Binary Tree는 배열로 효율적으로 표현할 수 있음

Heap (힙)
- 힙은 완전 이진 트리 형태를 가지며, 최대 힙과 최소 힙 두 가지 유형이 있음
- 최대 힙에서는 부모 노드가 자식 노드보다 큰 값을 가지며, 최소 힙에서는 반대로 부모 노드가 자식 노드보다 작은 값을 가짐
- 힙에서 데이터를 추가하거나 추출할 때, 힙의 특성을 유지하도록 조정

배열을 힙으로 만드는 방법
- 배열을 힙으로 만들기 위해서는 배열 원소들을 힙 조건을 만족하도록 구성
- 배열을 힙으로 만들 때, 상향식(heapify-up)과 하향식(heapify-down) 두 가지 방법을 사용할 수 있음
*상향식은 배열의 끝에서부터 힙을 구성하는 방법이며, 하향식은 루트 노드에서부터 힙을 구성하는 방법
- 배열을 힙으로 만들면, 최대값(루트 노드)을 배열의 끝으로 보내고 배열 크기를 줄여가며 정렬을 수행
- 이 과정을 반복하여 배열을 정렬

* 배열에서 i번째 원소의 부모는 (i-1)//2 인덱스에 위치, 왼쪽 자식은 2i+1 인덱스에 위치, 오른쪽 자식은 2i+2 인덱스에 위치

Heap Sort 작동 방식
- 주어진 배열을 최대 힙(Max Heap) 구조로 만듬
*이 때, 배열을 힙 자료 구조로 변환하는 작업은 O(n) 시간복잡도를 가짐
- 최대 힙의 루트 노드를 배열의 가장 끝 요소와 교환합니다. 이로써 가장 큰 값이 배열의 끝으로 이동
- 배열에서 가장 큰 값을 제외하고 남은 부분을 다시 최대 힙 구조로 만듬
- 위 과정을 반복하여 배열을 정렬

*힙 정렬은 정렬된 결과를 원본 배열에 바로 저장하기 때문에 추가적인 메모리를 사용하지 않는 효율적인 알고리즘

시간 복잡도
- Heap Sort의 시간 복잡도는 O(n log n) 
*힙 구조를 구성하는 데 O(n) 시간이 걸리고, 각 단계에서 최대 힙을 유지하는 작업은 O(log n)번 반복되기 때문
- Heap Sort는 안정적인 정렬 알고리즘 중 하나
* 평균 및 최악의 경우에도 O(n log n) 시간 복잡도를 가지므로 대규모 데이터 정렬에 효과적
* 힙은 우선순위 큐와 같은 다른 응용 분야에서도 유용하게 활용
* 힙 정렬은 추가적인 배열이 필요하지 않으며, 항상 O(n log n)의 시간 복잡도를 보장 
* 병합 정렬과 같은 다른 정렬 알고리즘보다 효율적인 알고리즘 중 하나


>Radix Sort
 : https://www.youtube.com/watch?v=7heKwjqkY60
Counting Sort : 주어진 배열의 요소를 정렬하는 알고리즘
* 주어진 배열의 범위에 따라 작동함

시간 복잡도 : O(n+k)
*n은 배열의 크기, k는 배열 요소의 최대 범위
*k가 매우 큰 경우, 많은 메모리 공간을 필요로 하므로 사용하기 어려울 수 있므

Radix Sort : Counting Sort를 개선한 정렬 알고리즘, 주어진 배열의 자릿수를 기준으로 정렬함
*Radix Sort는 Counting Sort를 사용하기 때문에 먼저 Counting Sort를 이해해야함.

Ex)주어진 배열이 [391, 582, 59, 124, 134, 8, 192]인 경우

첫 번째 단계: 가장 낮은 자릿수부터 정렬
8, 192, 582, 124, 134, 55, 391
두 번째 단계: 두 번째 자릿수부터 정렬
8, 55, 124, 134, 192, 391, 582
세 번째 단계: 세 번째 자릿수부터 정렬
8, 55, 124, 134, 192, 391, 582

* 먼저 자릿수 별로 정렬한 다음, 각 단계에서의 정렬은 안정적인 정렬이 되어야 함.
* 위의 과정을 통해 전체 배열이 오름차순으로 정렬됨

Counting Sort와 Radix Sort의 시간 복잡도는 동일함 : O(n+k)
*k는 주어진 배열의 범위(자릿수)에 따라 다르게 결정
*Radix Sort는 주어진 배열의 자릿수에 따라 세번 정렬 작업을 수행

 : https://www.youtube.com/watch?v=eCnKp9bzErg

Radix Sort : 입력 데이터를 여러 자릿 수로 나누어 정렬하는 알고리즘, 이를 통해 문자열이나 다른 데이터 타입을 효과적으로 정렬할 수 있음

"자릿수를 기반으로 정렬하고, Stable한 정렬 알고리즘을 사용하여 입력 순서를 보존함."

자릿수와 범위
- Radix Sort는 각 자릿수마다 값을 비교, 정렬
*3자리 정수라면 세 자릿수를 각각 고려, 각 자릿수는 특정 범위 내의 값을 가짐

정렬 과정
- 가장 낮은 자릿수부터 시작하여 가장 높은 자릿수까지 차례대로 정렬
- 각 자릿수를 기준으로 정렬된 결과는 다음 단계에서도 유지

Stable Sort : Radix Sort는  Stable한 정렬 알고리즘이어야 함(동일한 값들의 상대적인 순서를 입력 순서와 동일하게 유지)
*3자리 정수일 때 가장 낮은 자릿수부터 정렬을 시작, 이후 자릿수를 하나씩 높여가며 정렬

-알고리즘의 간결함 : Radix Sort는 간단한 알고리즘이며, 각 자릿수를 기준으로 정렬하기 대문에 이해하기 쉽다.

선택 정렬(Selection Sort):
- 시간 복잡도: O(n^2)
- 가장 작은 값을 찾아 맨 앞으로 이동시키며 정렬하는 방식.

버블 정렬(Bubble Sort):
- 시간 복잡도: O(n^2)
- 인접한 두 원소를 비교하여 순차적으로 정렬하는 방식.

삽입 정렬(Insertion Sort):
- 시간 복잡도: O(n^2)
- 각 원소를 적절한 위치에 삽입하면서 정렬하는 방식.

퀵 소트(Quick Sort):
- 시간 복잡도: 평균 O(n log n), 최악 O(n^2)
- Pivot을 기준으로 작은 값과 큰 값을 분할하여 정렬하는 방식. 
*최악의 경우는 정렬되지 않은 상태에서 Pivot을 선택할 때.

병합 소트(Merge Sort):
- 시간 복잡도: O(n log n)
- 분할 정복 알고리즘을 사용하여 배열을 반으로 나눈 후 병합하여 정렬하는 방식.

계수 정렬(Counting Sort):
- 시간 복잡도: O(n + k)
*여기서 k는 데이터가 가질 수 있는 서로 다른 값의 개수.
- 데이터의 분포를 이용하여 정렬하는 방식. 데이터의 크기 범위가 작을 때 유용.

스태블 정렬(Stable Sort):
- 정렬 중 동일한 값의 상대적인 순서가 유지되는 특성.

시간 복잡도 비교
- 선택 정렬과 버블 정렬은 최악의 경우에도 O(n^2)의 시간 복잡도를 가짐.
- 퀵 소트와 병합 소트는 평균적으로 O(n log n)의 시간 복잡도를 가지지만, 퀵 소트의 최악의 경우는 O(n^2)임.
- 계수 정렬은 O(n + k)로, 데이터 크기 범위가 작을 때 유용.

정렬 알고리즘의 선택
- 정렬 알고리즘 선택은 데이터 크기, 분포, 정렬 상태, 시간 제한 등에 따라 다름
*퀵 소트와 병합 소트는 일반적으로 빠르지만 안정적인 정렬이 필요한 경우 병합 소트를 선택할 수 있음

정렬 알고리즘 최적화:정렬 알고리즘의 성능은 입력 데이터에 따라 달라질 수 있으며, 최적화가 필요할 수 있음

2. 다음 영상 및 페이지 방문을 하고 자료가 의미하는 것을 정리하라.

# Animation
https://www.toptal.com/developers/sorting-algorithms

# 15 Algorithms
https://www.youtube.com/watch?v=kPRA0W1kECg
이 영상은 이전 과제에서 이미 정리했으니, 새롭게 알게 된 것에 대해 추가 정리하도록 한다.